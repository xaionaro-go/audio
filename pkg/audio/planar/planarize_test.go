package planar

import (
	"bytes"
	"encoding/hex"
	"errors"
	"io"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestPlanarizeAndUnplanarize(t *testing.T) {
	for _, testCase := range []struct {
		Name     string
		TestCase []byte
	}{
		{Name: "simple", TestCase: must(hex.DecodeString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"))},
		{Name: "large", TestCase: must(hex.DecodeString("70D1A53A70D1A53A9145AC3A9145AC3A4C4DAF3A4C4DAF3A6011B73A6011B73A19B1AF3A19B1AF3ACE88A33ACE88A33A846AA13A846AA13A4E52973A4E52973A03668E3A03668E3AEA708B3AEA708B3A96A4823A96A4823AA50A843AA50A843AF663883AF663883A7AE57B3A7AE57B3A9EA9713A9EA9713A2D676D3A2D676D3A474E5C3A474E5C3A7B03623A7B03623AE2B2613AE2B2613A58A0473A58A0473A5A1E523A5A1E523AC939703AC939703AFAFD733AFAFD733A217B783A217B783AA8BE7E3AA8BE7E3AFD37833AFD37833A52318D3A52318D3ADB8D8D3ADB8D8D3A7236813A7236813AE6FA6B3AE6FA6B3A8585563A8585563A862A3B3A862A3B3A49E22D3A49E22D3A90C8283A90C8283A264D243A264D243A5EEE2D3A5EEE2D3A8688273A8688273A42BD0E3A42BD0E3A7EC0093A7EC0093A83730E3A83730E3A8C08103A8C08103A0BF4143A0BF4143ADE4E1A3ADE4E1A3AE047203AE047203A084E283A084E283A69672B3A69672B3A29E4253A29E4253AF441263AF441263A5AF3233A5AF3233AC8F40F3AC8F40F3A68A00C3A68A00C3A868B183A868B183A44BA0F3A44BA0F3AB758063AB758063A88C00C3A88C00C3A60670B3A60670B3A7B97F8397B97F839BE17DE39BE17DE398EFED1398EFED139EAD8C839EAD8C83944ABBC3944ABBC390736A9390736A939DC9C8739DC9C8739226F4739226F47399FF417399FF41739799C0D39799C0D393DA910393DA910399EBACC389EBACC38E6EAB138E6EAB1388791F8388791F838E663C338E663C338B2AA8738B2AA873812B6503812B65038C0ABA037C0ABA037EEDD6E38EEDD6E385B0CE5385B0CE538E27ADC38E27ADC387A48D7387A48D73812F3CE3812F3CE38D44B2F38D44B2F38C285ECB6C285ECB63B96E2373B96E237FEC48F38FEC48F38BB5FBF38BB5FBF386C6C69386C6C69383FA936B83FA936B8F5E3E8B6F5E3E8B6F3981E38F3981E3888986EB888986EB8183132B8183132B87A6A88387A6A8838882DC138882DC138E3E1B938E3E1B93895E1C53895E1C53873BE903873BE903843D48E3843D48E387231CC387231CC380AE4DC370AE4DC3786E295B786E295B7ACD889B6ACD889B618B2CFB818B2CFB8689BC2B8689BC2B8E618EA37E618EA37C4321238C4321238E9E73138E9E73138C5E84238C5E84238380060B7380060B753A7163853A7163844440C3944440C398397013983970139E686F138E686F1387CA902397CA902398223C2378223C2372A1A15B82A1A15B87FCF0A387FCF0A38599B0AB7599B0AB7DEF655B8DEF655B81C6AC1371C6AC13746F4EDB646F4EDB633E689B733E689B7"))},
	} {
		t.Run(testCase.Name, func(t *testing.T) {
			b := testCase.TestCase
			planarized := make([]byte, len(b))
			err := Planarize(2, 4, planarized, b)
			require.NoError(t, err)
			unplanarized := make([]byte, len(b))
			err = Unplanarize(2, 4, unplanarized, planarized)
			require.NoError(t, err)
			require.Equal(t, b, unplanarized)
		})
	}
}

func TestUnplanarizeReaderAndPlanarizeReader(t *testing.T) {
	b := must(hex.DecodeString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F"))
	orig := bytes.NewReader(b)
	unplanared := NewUnplanarizeReader(orig, 2, 4, 65536)
	planared := NewPlanarizeReader(unplanared, 2, 4, 65536)

	r, err := io.ReadAll(planared)
	require.True(t, errors.Is(err, io.EOF), err)
	require.Equal(t, b, r)
}
